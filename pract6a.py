#Design an application to simulate number puzzle problem 

#Python code:
import random
import itertools
import collections

# --- Class Node ---
class Node:
    # A class representing a Solver node
    # 'puzzle' is a Puzzle instance
    # 'parent' is the preceding node generated by the solver, if any
    # 'action' is the action taken to produce puzzle, if any
    
    def _init_(self, puzzle, parent = None, action = None):
        self.puzzle = puzzle
        self.parent = parent
        self.action = action

    @property
    def state(self):
        # Return a hashable representation of self
        return str(self)

    def _str_(self):
        return str(self.puzzle)
        
    @property
    def path(self):
        # Reconstruct a path from the root/parent
        node, p = self, []
        while node:
            p.append(node)
            node = node.parent
        yield from reversed(p)

    def _eq_(self, other):
        return self.state == other.state

    def _hash_(self):
        return hash(self.state)

# --- Class Puzzle ---
class Puzzle:
    # A class representing an 8-puzzle
    # board should be a square list of lists with integer entries 0 to width^2 - 1
    # e.g., [[1, 2, 3], [4, 0, 5], [7, 8, 6]]

    def _init_(self, board):
        self.board = board
        self.width = len(board)

    @property
    def solved(self):
        """
        The puzzle is solved if the flattened board's
        self.width * self.width numbers are in increasing
        order from left to right and the '0' tile is the last position
        on the board.
        """
        N = self.width * self.width
        # Target string: '123456780' for 3x3 board
        target_str = "".join(map(str, range(1, N))) + '0' 
        
        # Current board state flattened
        current_str = "".join(str(i) for row in self.board for i in row)
        
        return current_str == target_str

    @property
    def actions(self):
        """
        Return a list of 'move', 'action' pairs. 'move' can be called
        to return a new puzzle that results in sliding the '0' tile
        in the different direction of 'action'.
        """
        
        def create_move(at, to):
            return lambda board: self.move(board, at, to)

        moves = []
        for r, c in itertools.product(range(self.width), range(self.width)):
            if self.board[r][c] == 0:
                at = (r, c)
                break
        
        r, c = at
        
        # Directions: (dr, dc)
        directions = {
            'R': (0, 1), # Right
            'L': (0, -1), # Left
            'D': (1, 0), # Down
            'U': (-1, 0), # Up
        }
        
        for action, (dr, dc) in directions.items():
            nr, nc = r + dr, c + dc # new row, new column (to swap with 0)
            to = (nr, nc)
            
            # Check bounds
            if 0 <= nr < self.width and 0 <= nc < self.width:
                move = create_move(at, to)
                moves.append((move, action))
        
        return moves

    def shuffle(self):
        """Return a new puzzle that has been shuffled with 1000 random moves"""
        
        puzzle = self
        for _ in range(1000):
            # Select a random valid action
            move, _ = random.choice(puzzle.actions)
            puzzle = move(puzzle.board)
        return puzzle

    def copy(self):
        """Return a new puzzle with the same board as 'self'."""
        board_copy = []
        for row in self.board:
            board_copy.append(list(row))
        return Puzzle(board_copy)

    def move(self, board_state, at, to):
        """Return a new puzzle where 'at' and 'to' tiles have been swapped."""
        
        # Note: all moves should be 'actions' that have been executed
        
        copy_board = self.copy().board
        
        # Unpack coordinates
        ar, ac = at
        tr, tc = to
        
        # Swap
        copy_board[ar][ac], copy_board[tr][tc] = copy_board[tr][tc], copy_board[ar][ac]
        
        return Puzzle(copy_board)
        
    def pprint(self):
        """Prints the board nicely."""
        for row in self.board:
            print(row)
        print()

    def _str_(self):
        # Hashable representation (e.g., '123405786')
        return "".join(str(i) for row in self.board for i in row)

    def _iter_(self):
        # Yields each tile in the board, row by row
        for row in self.board:
            yield from row

# --- Class Solver (BREADTH FIRST SEARCH) ---
class Solver:
    # An '8-puzzle' solver
    # 'start' is a Puzzle instance
    
    def _init_(self, start):
        self.start = start

    def solve(self):
        """Perform breadth first search and return a path to the solution, if it exists"""
        
        queue = collections.deque([Node(self.start)])
        seen = {self.start.state}
        
        while queue:
            node = queue.popleft() # Use popleft for BFS
            
            if node.puzzle.solved:
                return node.path
                
            for move_func, action in node.puzzle.actions:
                child_puzzle = move_func(node.puzzle.board)
                child_node = Node(child_puzzle, node, action)

                if child_node.state not in seen:
                    queue.append(child_node)
                    seen.add(child_node.state)
                    
        return None # No solution found

# --- Example of Use ---
# Example board: Solved state 3x3
board = [[1, 2, 3], [4, 5, 6], [7, 8, 0]] 
puzzle = Puzzle(board)
puzzle = puzzle.shuffle() # Shuffle the solved board randomly

s = Solver(puzzle)
p = s.solve()

print("Starting work...")
print("Initial state:")
puzzle.pprint()
print("Solution path:")

if p:
    for node in p:
        if node.action:
            print(f"Action: {node.action}")
        node.puzzle.pprint()
else:
    print("No solution found for the current shuffled puzzle.")